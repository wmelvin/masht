import sys
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent

import markdown

from masht.__about__ import __version__

app_name = "masht"

app_title = f"{app_name} (v.{__version__})"

run_dt_utc = datetime.now(tz=timezone.utc)


def html_style():
    s = """
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 1rem 4rem;
        }
        h1 { color: silver; }
        a:link, a:visited {
            color: #00248F;
            text-decoration: none;
        }
        :link:hover,:visited:hover {
            color: #B32400;
            text-decoration: underline;
        }
        #footer {
            border-top: 1px solid black;
            font-size: x-small;
            margin-top: 2rem;
        }
    """
    return s.lstrip("\n").rstrip()


def html_head(title):
    return dedent(
        """
        <!DOCTYPE html>
        <!--
            WARNING: Do not edit this file. It is generated by {2}.
            Only edit the source Markdown file.
        -->
        <html lang="en">
        <head>
            <title>{0}</title>
            <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
            <style>
            {1}
            </style>
            <base target="_blank">
        </head>
        <body>
        <h1>{0}</h1>
        """
    ).format(title, html_style(), app_name)


def html_tail():
    return dedent(
        """
        <div id="footer">
          Created {0} by {1}.
        </div>
        </body>
        </html>
        """
    ).format(run_dt_utc.astimezone().strftime("%Y-%m-%d %H:%M"), app_title)


#  Checks the Markdown for lists not preceeded by a blank line.
def check_md(md: str):
    lines = md.splitlines()
    prev_li = False
    prev_blank = True
    for i, line in enumerate(lines, start=1):
        is_li = line.startswith("- ") or line.startswith("* ")
        if i > 1 and is_li and not (prev_li or prev_blank):
            print(f"WARNING: Lists should be preceeded by a blank line. At line {i}.")
        prev_li = is_li
        prev_blank = line == ""


def alter_html(html: str):
    """
    Alter the HTML to fix issues.

    The markdown module does not add a <pre> tag around <code> tags for
    multiline code blocks.
    """

    lines = html.splitlines()

    for i, line in enumerate(lines):
        #  This only works if there is a single <code> tag on the line.
        #  In the case of a inline code block followed by opening a multiline
        #  code block, this will not work. Normally the opening, and closing,
        #  of a multiline code block will stand alone.

        if ("<code>" in line) and ("<pre><code>" not in line) and ("</code>" not in line):
            lines[i] = line.replace("<code>", "<pre><code>")

        if ("</code>" in line) and ("</code></pre>" not in line) and ("<code>" not in line):
            lines[i] = line.replace("</code>", "</code></pre>")

    return "\n".join(lines)



def write_md_as_html(filename: str):
    md_path = Path(filename)
    print(f"Reading '{md_path}'.")

    if not md_path.exists():
        print(f"ERROR: '{md_path}' does not exist.")
        return

    if md_path.suffix.lower() != ".md":
        print(f"ERROR: '{md_path}' is not a Markdown file.")
        return

    out_path = md_path.with_suffix(".md.AS.html")
    print(f"Writing '{out_path}'.")

    html = html_head(f"{md_path.name} as HTML")

    md = md_path.read_text()
    check_md(md)
    as_html = markdown.markdown(md)
    as_html = alter_html(as_html)
    html += as_html

    html += html_tail()

    # print(html)

    out_path.write_text(html)


def main(arglist=None):
    print(f"\n{app_title}\n")

    if arglist is None:
        arglist = sys.argv[1:]

    usage_msg = "\nUSAGE: masht filename.md [filename2.md ...]\n"

    if len(arglist) < 1:
        print(usage_msg)
        return 1

    if arglist[0] == "-h" or arglist[0] == "--help":
        print(usage_msg)
        return 0

    for md_file in arglist:
        write_md_as_html(md_file)


if __name__ == "__main__":
    main()
